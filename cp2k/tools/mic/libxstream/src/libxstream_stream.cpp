/******************************************************************************
** Copyright (c) 2014-2015, Intel Corporation                                **
** All rights reserved.                                                      **
**                                                                           **
** Redistribution and use in source and binary forms, with or without        **
** modification, are permitted provided that the following conditions        **
** are met:                                                                  **
** 1. Redistributions of source code must retain the above copyright         **
**    notice, this list of conditions and the following disclaimer.          **
** 2. Redistributions in binary form must reproduce the above copyright      **
**    notice, this list of conditions and the following disclaimer in the    **
**    documentation and/or other materials provided with the distribution.   **
** 3. Neither the name of the copyright holder nor the names of its          **
**    contributors may be used to endorse or promote products derived        **
**    from this software without specific prior written permission.          **
**                                                                           **
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **
** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **
** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **
** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **
** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **
** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **
** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **
******************************************************************************/
/* Hans Pabst (Intel Corp.)
******************************************************************************/
#if defined(LIBXSTREAM_EXPORTED) || defined(__LIBXSTREAM)
#include "libxstream_stream.hpp"
#include "libxstream_workqueue.hpp"
#include "libxstream_workitem.hpp"
#include "libxstream_event.hpp"
#include "libxstream_alloc.hpp"

#include <libxstream_begin.h>
#include <algorithm>
#include <cstring>
#include <string>
#include <cstdio>
#if defined(LIBXSTREAM_STDFEATURES)
# include <atomic>
#endif
#include <libxstream_end.h>

// thread-safe signal generation (only needed when not generated by background thread)
//#define LIBXSTREAM_STREAM_SIGNAL_THREADSAFE
// actually check whether a signal is pending or not
//#define LIBXSTREAM_STREAM_CHECK_PENDING
// prefer to schedule a waiting stream
#define LIBXSTREAM_STREAM_SCHEDULE_WAITSTREAM


namespace libxstream_stream_internal {

static/*IPO*/ class registry_type {
public:
  registry_type()
    : m_nstreams(0)
  {
    libxstream_alloc_init();
    std::fill_n(m_signals, LIBXSTREAM_MAX_NDEVICES, 0);
    std::fill_n(m_streams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS), static_cast<libxstream_stream*>(0));
  }

  ~registry_type() {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));

    for (size_t i = 0; i < n; ++i) {
      const libxstream_stream* stream = m_streams[i];

      if (0 != stream) {
#if defined(LIBXSTREAM_INTERNAL_TRACE)
        const char *const name = stream->name();
        if (0 != name && 0 != *name) {
          LIBXSTREAM_PRINT(1, "stream=0x%llx (%s) is dangling!", reinterpret_cast<unsigned long long>(stream), name);
        }
        else {
          LIBXSTREAM_PRINT(1, "stream=0x%llx is dangling!", reinterpret_cast<unsigned long long>(stream));
        }
#endif
        libxstream_stream_destroy(m_streams[i]);
      }
    }
  }

public:
  size_t priority_range(int device, int& least, int& greatest) {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));

    for (size_t i = 0; i < n; ++i) {
      if (const libxstream_stream *const stream = m_streams[i]) {
        const int stream_device = libxstream_stream::device(stream);
        if (stream_device == device) {
          const int priority = stream->priority();
          least = std::min(least, priority);
          greatest = std::max(least, priority);
        }
      }
    }
    size_t result = 0;
    for (size_t i = 0; i < n; ++i) {
      if (const libxstream_stream *const stream = m_streams[i]) {
        const int stream_device = libxstream_stream::device(stream);
        if (stream_device == device) {
          const int priority = stream->priority();
          result += priority - greatest;
        }
      }
    }

    return result;
  }

  libxstream_stream*volatile& allocate() {
#if !defined(LIBXSTREAM_STDFEATURES)
    libxstream_lock *const lock = libxstream_lock_get(this);
    libxstream_lock_acquire(lock);
#endif
    libxstream_stream*volatile* i = m_streams + LIBXSTREAM_MOD2(m_nstreams++, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    while (0 != *i) i = m_streams + LIBXSTREAM_MOD2(m_nstreams++, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
#if !defined(LIBXSTREAM_STDFEATURES)
    libxstream_lock_release(lock);
#endif
    return *i;
  }

  libxstream_stream*volatile& find(const libxstream_stream* stream) {
    libxstream_stream*volatile *const end = m_streams + std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    libxstream_stream*volatile *const result = std::find(m_streams, end, stream);
    LIBXSTREAM_ASSERT(result != end);
    return *result;
  }

  size_t nstreams(int device, const libxstream_stream* end = 0) const {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));

    size_t result = 0;
    if (0 == end) {
      for (size_t i = 0; i < n; ++i) {
        const libxstream_stream *const stream = m_streams[i];
        result += (0 != stream && libxstream_stream::device(stream) == device) ? 1 : 0;
      }
    }
    else {
      for (size_t i = 0; i < n; ++i) {
        const libxstream_stream *const stream = m_streams[i];
        if (end != stream) {
          result += (0 != stream && libxstream_stream::device(stream) == device) ? 1 : 0;
        }
        else {
          i = n; // break
        }
      }
    }

    return result;
  }

  size_t nstreams() const {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    size_t result = 0;

    for (size_t i = 0; i < n; ++i) {
      const libxstream_stream *const stream = m_streams[i];
      result += 0 != stream ? 1 : 0;
    }

    return result;
  }

  libxstream_signal signal(int device) {
    LIBXSTREAM_ASSERT(-1 <= device && device <= LIBXSTREAM_MAX_NDEVICES);
#if defined(LIBXSTREAM_STDFEATURES) || !defined(LIBXSTREAM_STREAM_SIGNAL_THREADSAFE)
    return ++m_signals[device+1];
#elif defined(_OPENMP)
    libxstream_signal& device_signal = m_signals[device+1];
    libxstream_signal result = 0;
# if (201107 <= _OPENMP)
#   pragma omp atomic capture
# else
#   pragma omp critical
# endif
    result = ++device_signal;
    return result;
#else // generic
    libxstream_signal& device_signal = m_signals[device+1];
    libxstream_signal result = 0;
    libxstream_lock *const lock = libxstream_lock_get(this);
    libxstream_lock_acquire(lock);
    result = ++device_signal;
    libxstream_lock_release(lock);
    return result;
#endif
  }

  int enqueue(libxstream_event& event, const libxstream_stream* exclude) {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    int result = LIBXSTREAM_ERROR_NONE;
    bool reset = true;

    for (size_t i = 0; i < n && LIBXSTREAM_ERROR_NONE == result; ++i) {
      libxstream_stream *const stream = m_streams[i];

      if (stream != exclude) {
        result = event.record(*stream, reset);
        reset = false;
      }
    }

    LIBXSTREAM_ASSERT(LIBXSTREAM_ERROR_NONE == result);
    return result;
  }

  libxstream_stream* schedule(const libxstream_stream* exclude) {
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    libxstream_stream* result = 0;
    size_t start = 0, offset = 0;

    if (0 != exclude) {
      for (size_t i = 0; i < n; ++i) {
        libxstream_stream *const stream = m_streams[i];

        if (stream == exclude) {
          start = i;
          offset = 1;
          i = n; // break
        }
#if defined(LIBXSTREAM_STREAM_SCHEDULE_WAITSTREAM)
        else if (0 != stream) {
          const libxstream_workqueue::entry_type *const work = stream->work();
          const libxstream_workitem *const item = 0 != work ? work->item() : 0;
          if (0 != item && 0 != (LIBXSTREAM_CALL_WAIT & item->flags())) {
            result = stream;
          }
        }
#endif
      }
    }

#if defined(LIBXSTREAM_STREAM_SCHEDULE_WAITSTREAM)
    if (0 == result)
#endif
    {
      const size_t end = start + n;
      for (size_t i = start + offset; i < end; ++i) {
        libxstream_stream *const stream = m_streams[/*i%n*/i<n?i:(i-n)]; // round-robin
        if (0 != stream) {
          result = stream;
          i = end; // break
        }
      }
    }

    return result;
  }

  int wait_all(int device, const libxstream_stream* exclude) { // TODO: implement waiting for global stream
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    int result = LIBXSTREAM_ERROR_NONE;

    if (0 < n) {
#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
      if (0 <= device) {
        LIBXSTREAM_ASYNC_BEGIN
        {
          LIBXSTREAM_PRINT0(2, "stream_wait: wait for all streams");
#         pragma offload_wait target(mic) stream(0)
        }
        LIBXSTREAM_ASYNC_END(0, LIBXSTREAM_CALL_DEFAULT | LIBXSTREAM_CALL_DEVICE | (0 == exclude ? LIBXSTREAM_CALL_WAIT : 0), work, device);
        result = work.wait(exclude);
      }
      else
#endif
      {
        size_t i = 0;
        LIBXSTREAM_PRINT0(2, "stream_wait: wait for all streams");
        do {
          libxstream_stream *const stream = m_streams[i];

          if (stream != exclude || 0 != stream) {
            const int stream_device = libxstream_stream::device(stream);
            if (stream_device == device) {
              result = 0 != m_streams[i] // late check
                ? stream->wait()
                : LIBXSTREAM_ERROR_NONE;
            }
          }
          ++i;
        }
        while(i < n && LIBXSTREAM_ERROR_NONE == result);
      }
    }

    LIBXSTREAM_ASSERT(LIBXSTREAM_ERROR_NONE == result);
    return result;
  }

  int wait_all(const libxstream_stream* exclude) { // TODO: implement waiting for global stream
    const size_t n = std::min<size_t>(m_nstreams, (LIBXSTREAM_MAX_NDEVICES) * (LIBXSTREAM_MAX_NSTREAMS));
    int result = LIBXSTREAM_ERROR_NONE;

    if (0 < n) {
      bool devices[(LIBXSTREAM_MAX_NDEVICES)+1];
      size_t i = 0;
      LIBXSTREAM_PRINT0(2, "stream_wait: wait for all streams");
      std::fill_n(devices, (LIBXSTREAM_MAX_NDEVICES)+1, false);
      do {
        const libxstream_stream *const stream = m_streams[i];

        if (stream != exclude || 0 != stream) {
          const int device = libxstream_stream::device(stream);
          devices[device+1] = true;
        }
        ++i;
      }
      while(i < n);

      for (i = 0; i <= (LIBXSTREAM_MAX_NDEVICES) && LIBXSTREAM_ERROR_NONE == result; ++i) {
        result = devices[i] ? wait_all(static_cast<int>(i) - 1, exclude) : LIBXSTREAM_ERROR_NONE;
      }
    }

    LIBXSTREAM_ASSERT(LIBXSTREAM_ERROR_NONE == result);
    return result;
  }

private:
  libxstream_stream*volatile m_streams[(LIBXSTREAM_MAX_NDEVICES)*(LIBXSTREAM_MAX_NSTREAMS)];
#if defined(LIBXSTREAM_STDFEATURES) && defined(LIBXSTREAM_STREAM_SIGNAL_THREADSAFE)
  std::atomic<libxstream_signal> m_signals[(LIBXSTREAM_MAX_NDEVICES)+1];
#else
  libxstream_signal m_signals[(LIBXSTREAM_MAX_NDEVICES)+1];
#endif
#if defined(LIBXSTREAM_STDFEATURES)
  std::atomic<size_t> m_nstreams;
#else
  size_t m_nstreams;
#endif
} registry;

} // namespace libxstream_stream_internal


/*static*/int libxstream_stream::priority_range_least()
{
#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
  const int result = LIBXSTREAM_MAX_NTHREADS;
#else // not supported (empty range)
  const int result = 0;
#endif
  return result;
}


/*static*/int libxstream_stream::priority_range_greatest()
{
#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
  const int result = 0;
#else // not supported (empty range)
  const int result = 0;
#endif
  return result;
}


/*static*/int libxstream_stream::device(const libxstream_stream* stream)
{
  int result = -1;
  if (0 != stream) {
    result = stream->m_device;
  }
  else {
    LIBXSTREAM_CHECK_CALL_ASSERT(libxstream_get_active_device(&result));
  }
  return result;
}


/*static*/libxstream_signal libxstream_stream::signal(int device)
{
  return libxstream_stream_internal::registry.signal(device);
}


/*static*/libxstream_signal libxstream_stream::pending(const libxstream_stream* stream)
{
  libxstream_signal result = 0 != stream ? stream->m_pending : 0; // TODO: handle global stream

#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && !defined(__MIC__) && defined(LIBXSTREAM_ASYNC) && (1 < (2*LIBXSTREAM_ASYNC+1)/2) && defined(LIBXSTREAM_STREAM_CHECK_PENDING)
  if (0 != result && 0 != _Offload_signaled(libxstream_stream::device(stream), reinterpret_cast<void*>(result))) {
    result = 0;
  }
#endif

  return result;
}


/*static*/void libxstream_stream::pending(libxstream_stream* stream, libxstream_signal signal)
{
  if (0 != stream) {
    stream->m_pending = signal;
  }
#if 0 // TODO: handle global stream
  else {
  }
#endif
}


/*static*/int libxstream_stream::enqueue(libxstream_event& event, const libxstream_stream* exclude)
{
  return libxstream_stream_internal::registry.enqueue(event, exclude);
}


/*static*/libxstream_stream* libxstream_stream::schedule(const libxstream_stream* exclude)
{
  return libxstream_stream_internal::registry.schedule(exclude);
}


/*static*/int libxstream_stream::wait_all(int device, const libxstream_stream* exclude)
{
  return libxstream_stream_internal::registry.wait_all(device, exclude);
}


/*static*/int libxstream_stream::wait_all(const libxstream_stream* exclude)
{
  return libxstream_stream_internal::registry.wait_all(exclude);
}


libxstream_stream::libxstream_stream(int device, int priority, const char* name)
#if defined(LIBXSTREAM_STREAM_CACHED_REGCHECK)
  : m_registered(0), m_pending(0), m_device(device), m_priority(priority)
#else
  : m_pending(0), m_device(device), m_priority(priority)
#endif
#if defined(LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
  , m_handle(0) // lazy creation
  , m_npartitions(0)
#endif
{
  // sanitize the stream priority
  const int priority_least = priority_range_least(), priority_greatest = priority_range_greatest();
  m_priority = std::max(priority_greatest, std::min(priority_least, priority));
  LIBXSTREAM_PRINT(m_priority != priority ? 2 : 0, "stream priority %i has been clamped to %i", priority, m_priority);

#if defined(LIBXSTREAM_INTERNAL_TRACE)
  if (0 != name && 0 != *name) {
    const size_t length = std::min(std::char_traits<char>::length(name), sizeof(m_name) - 1);
    memcpy(m_name, name, length);
    m_name[length] = 0;
  }
  else {
    m_name[0] = 0;
  }
#else
  libxstream_sink(name);
#endif

  libxstream_stream*volatile& entry = libxstream_stream_internal::registry.allocate();
#if defined(LIBXSTREAM_STREAM_CACHED_REGCHECK)
  m_registered = &entry;
#endif
  entry = this;
}


libxstream_stream::~libxstream_stream()
{
  LIBXSTREAM_CHECK_CALL_ASSERT(wait());

  // deregister stream
  registered() = 0;

#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && !defined(__MIC__) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
  if (0 != m_handle) {
    _Offload_stream_destroy(m_device, m_handle);
  }
#endif
}


const libxstream_stream*volatile& libxstream_stream::registered() const
{
  libxstream_stream*volatile* result = 0;
#if defined(LIBXSTREAM_STREAM_CACHED_REGCHECK)
  result = m_registered;
#else
  result = &libxstream_stream_internal::registry.find(this);
#endif
  return *const_cast<const libxstream_stream*volatile*>(result);
}


libxstream_stream*volatile& libxstream_stream::registered()
{
  libxstream_stream*volatile* result = 0;
#if defined(LIBXSTREAM_STREAM_CACHED_REGCHECK)
  result = m_registered;
#else
  result = &libxstream_stream_internal::registry.find(this);
#endif
  return *result;
}


libxstream_workqueue::entry_type& libxstream_stream::enqueue(libxstream_workitem& workitem)
{
  LIBXSTREAM_ASSERT(0 != workitem.stream() && this == *workitem.stream());
  libxstream_workqueue::entry_type& entry = m_queue.allocate_entry();
  entry.push(workitem);
  return entry;
}


int libxstream_stream::wait()
{
  LIBXSTREAM_ASYNC_BEGIN
  {
#if defined(LIBXSTREAM_INTERNAL_TRACE)
    LIBXSTREAM_ASSERT(0 != LIBXSTREAM_ASYNC_STREAM);
    const char *const name = LIBXSTREAM_ASYNC_STREAM->name();
    if (0 != name && 0 != *name) {
      LIBXSTREAM_PRINT(2, "stream_wait: stream=0x%llx (%s)", reinterpret_cast<unsigned long long>(LIBXSTREAM_ASYNC_STREAM), name);
    }
    else {
      LIBXSTREAM_PRINT(2, "stream_wait: stream=0x%llx", reinterpret_cast<unsigned long long>(LIBXSTREAM_ASYNC_STREAM));
    }
#endif
#if defined(LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (1 < (2*LIBXSTREAM_ASYNC+1)/2)
    if (0 != (LIBXSTREAM_ASYNC_PENDING) && 0 <= LIBXSTREAM_ASYNC_DEVICE) {
#     pragma offload_wait LIBXSTREAM_ASYNC_TARGET_WAIT
    }
#endif
  }
  LIBXSTREAM_ASYNC_END(this, LIBXSTREAM_CALL_DEFAULT | LIBXSTREAM_CALL_WAIT, work);

  const int result = work.wait();
  LIBXSTREAM_ASSERT(LIBXSTREAM_ERROR_NONE == result);

  return result;
}


#if defined(LIBXSTREAM_OFFLOAD) && (0 != LIBXSTREAM_OFFLOAD) && defined(LIBXSTREAM_ASYNC) && (3 == (2*LIBXSTREAM_ASYNC+1)/2)
_Offload_stream libxstream_stream::handle() const
{
  const size_t nstreams = libxstream_stream_internal::registry.nstreams(m_device);

  if (nstreams != m_npartitions) {
    if (0 != m_handle) {
      const_cast<libxstream_stream*>(this)->wait(true); // complete pending operations on old stream
      _Offload_stream_destroy(m_device, m_handle);
    }

    const int nthreads_total = omp_get_max_threads_target(TARGET_MIC, m_device) - 4/*reserved core: threads per core*/;
    const int priority_least = priority_range_least(), priority_greatest = priority_range_greatest();
    LIBXSTREAM_ASSERT(priority_greatest <= priority_least);

    int priority_least_device = priority_least, priority_greatest_device = priority_greatest;
    const size_t priority_sum = libxstream_stream_internal::registry.priority_range(m_device, priority_least_device, priority_greatest_device);
    LIBXSTREAM_ASSERT(priority_greatest_device <= priority_least_device && priority_greatest_device <= m_priority);
    const size_t priority_range_device = priority_least_device - priority_greatest_device;
    LIBXSTREAM_ASSERT(priority_sum <= priority_range_device);

    const size_t istream = libxstream_stream_internal::registry.nstreams(m_device, this); // index
    const size_t denominator = 0 == priority_range_device ? nstreams : (priority_range_device - priority_sum);
    const size_t nthreads = (0 == priority_range_device ? nthreads_total : (priority_range_device - (m_priority - priority_greatest_device))) / denominator;
    const size_t remainder = nthreads_total - nthreads * denominator;
    const int ithreads = static_cast<int>(nthreads + (istream < remainder ? 1/*imbalance*/ : 0));

    LIBXSTREAM_PRINT(3, "stream=0x%llx is mapped to %i threads", reinterpret_cast<unsigned long long>(this), ithreads);
    m_handle = _Offload_stream_create(m_device, ithreads);
    m_npartitions = nstreams;
  }

  return m_handle;
}
#endif

const libxstream_stream* cast_to_stream(const void* stream)
{
  return static_cast<const libxstream_stream*>(stream);
}


libxstream_stream* cast_to_stream(void* stream)
{
  return static_cast<libxstream_stream*>(stream);
}


const libxstream_stream* cast_to_stream(const libxstream_stream* stream)
{
  return stream;
}


libxstream_stream* cast_to_stream(libxstream_stream* stream)
{
  return stream;
}


const libxstream_stream* cast_to_stream(const libxstream_stream& stream)
{
  return &stream;
}


libxstream_stream* cast_to_stream(libxstream_stream& stream)
{
  return &stream;
}

#endif // defined(LIBXSTREAM_EXPORTED) || defined(__LIBXSTREAM)
